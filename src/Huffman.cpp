#include <iostream>
#include <queue>
#include <string>
#include <stdint.h>
#include <sstream>
#include <bitset>
#include <unordered_map>
#include <utility>

using namespace std;

class HuffmanNode {
public:
    char data;
    unsigned freq;
    HuffmanNode *left;
    HuffmanNode *right;

    HuffmanNode(char data, unsigned freq, HuffmanNode *left, HuffmanNode *right) {
        this->data = data;
        this->freq = freq;
        this->left = left;
        this->right = right;
    }

    HuffmanNode(char data, unsigned freq) {
        this->data = data;
        this->freq = freq;
        left = right = nullptr;
    }
};

// Function object to be used as a custom comparator
struct compare {
    bool operator()(HuffmanNode *left, HuffmanNode *right) {
        return (left->freq > right->freq);
    }
};

string encode(const string &data, const unordered_map<char, string> &huffmanCode);
string decode(const string &encodedData, HuffmanNode *root);


/**
 * Converts a string of binary into ascii
 * String will be buffered by zero if data is not divisable by 8
 * @param 
 * @return An ascii version of the binary. Note: It will always end with a null value
 */
string binaryToASCII(string& data){
    if (data.empty()){
        return nullptr;
    }

    // buffers the string of binary with 0's as needed
    if (data.length() % 8 != 0){
        int bufferAmount = 8 - (data.length()%8);
        data.append(bufferAmount, '0');
    }


    // converts the string of binary to ascii
    std::stringstream sstream(data);
    std::string output;
    while(sstream.good())
    {
        std::bitset<8> bits;
        sstream >> bits;
        char c = char(bits.to_ulong());
        output += c;
    }

    return output;
}

/**
 * converts ascii to binary
 */
std::string asciiToBinary(const string& asciiString, uint64_t bitcount) {
    if (asciiString.empty()){
        return nullptr;
    }

    // ascii to binary
    std::string binaryString = "";
    for (char c : asciiString) {
        binaryString += std::bitset<8>(c).to_string();
    }
    return binaryString.substr(0, bitcount);
}


/**
 * @brief Build the Huffman Tree by repeatedly combining two nodes with the lowest frequncies
 * into a new until there is only one node left. The last node will become the root of the tree
 *
 * @param string of data to build the Huffman tree
 * @return Root of the newly built Huffman tree
 */
HuffmanNode *buildTree(string data) {
    // Use an unordered map to count the occurences of characters
    unordered_map<char, unsigned> freq;
    for (char c : data) {
        freq[c]++;
    }

    // Minheap to store the nodes of the tree based on frequencies
    priority_queue<HuffmanNode *, vector<HuffmanNode *>, compare> minHeap;

    // Create a new node for each character and add node to the minHeap
    for (auto &pair : freq) {
        minHeap.push(new HuffmanNode(pair.first, pair.second));
    }

    while (minHeap.size() != 1) {
        // Removes 2 nodes with the lowest frequency from the minHeap
        HuffmanNode *left = minHeap.top();
        minHeap.pop();
        HuffmanNode *right = minHeap.top();
        minHeap.pop();

        // Create a node to connect the left and right nodes, using the left and right sum as frequency
        int sum = left->freq + right->freq;
        minHeap.push(new HuffmanNode('$', sum, left, right));
    }

    // Return the reamaining node in the minHeap. This is the root node.
    return minHeap.top();
}

/**
 * @brief
 *
 * @param root The root of the Huffman tree
 * @param str The original data
 * @param huffmanCode Map to store the generated Huffman codes
 */
void printCodes(HuffmanNode *root, string str, unordered_map<char, string> &huffmanCode) {
    if (!root)
        return;

    if (root->data != '$') {
        huffmanCode[root->data] = str;
    }

    printCodes(root->left, str + "0", huffmanCode);
    printCodes(root->right, str + "1", huffmanCode);
}

/**
 * @brief Methods reads the original string and encode it using the
 * "alphabet" generated by the Huffman tree
 *
 * @param data Original string to be proccessed
 * @param huffmanCode Map storing the Huffman
 * @return string String of the encoded data from the tree
 */
string encodeData(const string &data, const unordered_map<char, string> &huffmanCode) {
    string encodedData;

    for (char c : data) {
        encodedData += huffmanCode.at(c);
    }

    return encodedData;
}

/**
 * @brief Traverse the Huffman tree to create a string representation of the tree
 *
 * @param root Pointer to the root of the Huffman tree
 * @param res String representation of the tree
 */
void treeAsString(HuffmanNode *root, string &res) {
    if (!root)
        return;

    // If it is a leaf node, append '1' and the character to the string.
    // If not a leaf node, append '0' to the string.
    if (!root->left && !root->right) {
        res += '1';
        res += root->data;
    } else {
        res += '0';
    }

    // Recursively traverse the tree
    treeAsString(root->left, res);
    treeAsString(root->right, res);
}

/**
 * @brief
 *
 * @param data
 * @return pair<string, HuffmanNode *> Encoded data as a string and the root of the Huffman tree
 */
pair<string, HuffmanNode *> HuffmanCodes(const string &data) {
    if (data.empty())
        return {"", nullptr};

    // Build the Huffman tree
    HuffmanNode *root = buildTree(data);

    unordered_map<char, string> huffmanCode;
    printCodes(root, "", huffmanCode);

    string encodedResult = encodeData(data, huffmanCode);

    return {encodedResult, root};
}

string HuffmanDecompress(const string &encodedData, HuffmanNode *root) {
    string decodedData;
    HuffmanNode *currentNode = root;

    for (char bit : encodedData) {
        if (bit == '0') {
            currentNode = currentNode->left;
        } else if (bit == '1') {
            currentNode = currentNode->right;
        }
        // Leaf node
        if (!currentNode->left && !currentNode->right) {
            decodedData += currentNode->data;
            currentNode = root; // Go back to the root for the next character
        }
    }

    return decodedData;
}

int main() {
    string test = "KDBxCGDc1dCZnwMFrhaoAxhIOi5ydmn1JFpgVzsnlTM2h7IUnP6fYNqZHr3Q2BBIfGDq2JOstNkuet837VnJvVpW1PxMPqsUYHqKuOxiIJtOBjUdouqNVcgZw3288lc6SD2uu069MZJzlvtVBWDwJn0wd2JBQ1f4j3Ul2fWxFTfRtuLXxZ8vd6VHEavN186eASqW2IYa9PaZA2WgQjpBxtfk6NuVSMapkBQnsfhJpCyhNUpysR9iEAlexefOr0oXLd0cdW84kiheZ5Pgt0chXT4wHV4NE04CxnqD91sNpP7alN2BrDK1olhERBhJCv3ypWZJv40LNUWvnZqcHicLpPMGXBXAmsvT7TJKPiNQQAVA2ZKL8yI8Jh3IqiBL6of1IxGXWW2Zb2eZxMWWpJDA4JTlT6gYtibBFBJJpbPR7a4wxlvCY93wjwuLce8uunSI5iE5o1AnDyDOAJWpoCaB5J6z0afB7kyaXoS6bq2H9bXAgRrFj0seQ20wLQj5ipVnvCFVSRPPjUMfGUiWQQCCD6OKZDmJGPzG4LcRJJot4lsyte9tpWeZzY9JAZL2Okj2Vt5R2By40Pd47PZ6bkO29auXPHy8OGRDDUxWGwp0pbTs7Qb6fsGfSeTUb6vEKdpXAEbslNekpJEt3IO4j6FyZyricXl0GRaOUqNbJZTiElfi8e8FjRLK0LsNrSzhCSQ1F5sfvGOCChHhHI2VAX9KhIDm85d7eOr5pFDtQqfxA8o1RNhyV1ugIJ8eglKpp8xfFoUEzFuqAGEpoHfuvXGPFzrkUz5iPGA8jHvLX6MBFY4BqdvnSAtKXvrbLqZIY2J6QYNYwwOxaJHIqwjOvCyXLQYPSDwPlVPPrYDqsQRKvaK8Z3rJ40S1sKvceto6oMBuAnLinubnBqo9KYIn3ttu1OuRcIl4VeozraQN4yXavNv4MLDjiAGmBzyRAIo0gSbvJMKGw4g2OrT75pG7rv4OMRHbMLJM8hF2DVSJojJ6";

    cout << test << endl;

    pair<string, HuffmanNode *> p = HuffmanCodes(test);

    string res = p.first;

    cout << res << endl;

    string decomp = HuffmanDecompress(res, p.second);

    string tree;

    treeAsString(p.second, tree);

    cout << tree << endl;

    cout << decomp << endl;

    return 0;
}